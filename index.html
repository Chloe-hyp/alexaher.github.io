<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Node-js" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/26/Node-js/" class="article-date">
  <time datetime="2022-05-26T13:51:24.000Z" itemprop="datePublished">2022-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/26/Node-js/">Node.js</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="1-认识"><a href="#1-认识" class="headerlink" title="1. 认识"></a>1. 认识</h2><h3 id="回顾："><a href="#回顾：" class="headerlink" title="回顾："></a>回顾：</h3><ul>
<li><p>Javascript解析引擎：JavaScript在浏览器中被执行因为有解析引擎的存在。不同浏览器使用不同的javascript解析引擎</p>
</li>
<li><p>Web API：浏览器内置了DOM、BOM、Ajax这样的API函数，因此浏览器中的JavaScript可以调用它们，操作DOM、BOM元素。</p>
</li>
<li><p>浏览器运行环境：代码正常运行所需的必要环境。包括，JavaScript解析引擎，浏览器内置API。内置API是由运行环境提供的特殊接口，也就是说脱离了运行环境就无法执行。（前端开发）</p>
</li>
</ul>
<h3 id="认识node-js"><a href="#认识node-js" class="headerlink" title="认识node.js"></a>认识node.js</h3><p>Node.js是基于Chrome V8引擎的JavaScript运行环境。（JavaScript在node.js环境中运行是后端开发）</p>
<p>Node.js运行环境：V8引擎（解析执行JavaScript），内置API（fs,path,http,JS内置对象,querystring…)</p>
<p>Node.js无法调用DOM、BOM等浏览器内置API，因为内置API只能在特定运行环境中调用。</p>
<h3 id="Node-js可以做什么"><a href="#Node-js可以做什么" class="headerlink" title="Node.js可以做什么"></a>Node.js可以做什么</h3><p>基于Express框架，可以快速构建Web应用</p>
<p>基于Electron框架，可以构建跨平台的桌面应用</p>
<p>基于restify框架，可以快速构建API接口项目，可以编写接口实现后端功能</p>
<h3 id="Node版本"><a href="#Node版本" class="headerlink" title="Node版本"></a>Node版本</h3><p>LTS：长期稳定</p>
<p>current：适合于用新特性的</p>
<h3 id="Node-js环境执行js代码"><a href="#Node-js环境执行js代码" class="headerlink" title="Node.js环境执行js代码"></a>Node.js环境执行js代码</h3><ol>
<li><p>终端</p>
<p>打开终端；输入node +js文件路径</p>
</li>
<li><p>右键打开power shell可以直接在终端中定位到当前目录</p>
</li>
</ol>
<h2 id="2-fs文件系统模块"><a href="#2-fs文件系统模块" class="headerlink" title="2. fs文件系统模块"></a>2. fs文件系统模块</h2><p>fs模块是node.js官方提供的，用来操作文件的模块，它提供了一系列的方法和属性，用来满足用户对文件的操作需求。</p>
<h3 id="1-导入fs"><a href="#1-导入fs" class="headerlink" title="1. 导入fs"></a>1. 导入fs</h3><p>输入语句：const fs=require(‘fs’);</p>
<h3 id="2-读取指定文件中的内容"><a href="#2-读取指定文件中的内容" class="headerlink" title="2. 读取指定文件中的内容"></a>2. 读取指定文件中的内容</h3><ol>
<li>fs.readFile()</li>
</ol>
<p><strong>fs.readFile(path, options , callback);</strong><br>//参数一：必选参数，字符串，表示文件路径</p>
<p>//参数二：可选参数，表示以什么编码方式读取文件<br>//参数三：必选参数，文件读取完成后，通过回调函数拿到读取结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">//以utf8的编码格式，读取指定文件的内容，并打印err和datastr的值.成功打印dataStr，失败打印err</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,dataStr</span>)&#123;</span><br><span class="line">    <span class="comment">//读取成功，则err值为null；读取失败，则err的值为错误对象，datastr的值为undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dataStr);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>判断文件是否读取成功</li>
</ol>
<p>通过判断err对象是否为null，从而得知文件是否读取成功。err若能转为true，则说明读取失败。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,dataStr</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败！&#x27;</span>+err.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取成功&#x27;</span>+dataStr);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-向指定文件写入内容"><a href="#3-向指定文件写入内容" class="headerlink" title="3.  向指定文件写入内容"></a>3.  向指定文件写入内容</h3><ol>
<li>fs.writeFile()</li>
</ol>
<p><strong>fs.writeFile(file, data[,options], callback);</strong></p>
<p>//参数一：必选，指定文件路径字符串。<strong>如果文件不存在将会自动创建，但是不会自动创建路径（文件夹）</strong></p>
<p>//参数二：必选，写入字符串</p>
<p>//参数三：可选，表示以什么编码格式写入文件内容，默认utf-8</p>
<p>//参数四：必选，文件写入后的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fa=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./2.txt&#x27;</span>,<span class="string">&#x27;吃屎吧你&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">    <span class="comment">//文件写入成功，则err为null；文件写入失败，则err为错误对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>判断文件是否写入成功</li>
</ol>
<p>通过err对象判断是否写入成功，成功则err为null，否则可转为true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fa=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./2.txt&#x27;</span>,<span class="string">&#x27;吃屎吧你&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件写入失败&#x27;</span>+err.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件写入成功！&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-案例：成绩整理"><a href="#4-案例：成绩整理" class="headerlink" title="4. 案例：成绩整理"></a>4. 案例：成绩整理</h3><p>获取成绩文件，改变文件中的数据格式，写入新文件中。</p>
<ol>
<li><p>先把成绩的数据按照空格进行分割，得到数组。split（分隔符）</p>
</li>
<li><p>循环分割后的数组，对每一项数据进行字符串替换操作。replace（）</p>
</li>
<li><p>将新数组进行合并，得到字符串，写入文件中。join（）</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,dataStr</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败！&#x27;</span>+err.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取成功&#x27;</span>+dataStr);</span><br><span class="line">    <span class="keyword">const</span> arrOld=dataStr.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> arrNew=[];</span><br><span class="line">    arrOld.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        arrNew.<span class="title function_">push</span>(item.<span class="title function_">replace</span>(<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27;:&#x27;</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> newStr= arrNew.<span class="title function_">join</span>(<span class="string">&#x27;\r\n&#x27;</span>);</span><br><span class="line">    fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./2.txt&#x27;</span>,newStr,<span class="string">&#x27;utf-8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件写入失败&#x27;</span>+err.<span class="property">message</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件写入成功！&#x27;</span>);</span><br><span class="line">    &#125;)  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5-路径动态拼接问题"><a href="#5-路径动态拼接问题" class="headerlink" title="5. 路径动态拼接问题"></a>5. 路径动态拼接问题</h3><p>拼接出的路径不正确</p>
<p>以相对路径./或../拼接文件路径（被操作文件相对于当前代码文件）时，容易出问题，因为代码在运行时会<strong>以执行node命令时所在目录cd</strong>（不是被执行代码文件所在目录），动态拼接出被操作文件的绝对路径。</p>
<p>比如js文件在终端中上上层目录中被执行（执行时js文件路径当然加上后面的目录），但是被操作的文件在执行时拼接相对路径会直接以当前执行所在的目录为父目录，所以可能找不到文件，而不是以js代码文件所在目录为父目录，就很难搞。</p>
<p>解决方案：写成<strong>绝对路径</strong>不会有问题。</p>
<p>“./“表示当前目录写不写都可，”../“当前目录的上层目录。</p>
<p>绝对路径的”\ \  “注意 “ \ “ 会出现<strong>转义问题</strong>。但绝对路径移植性很差。</p>
<p>解决方案：**__dirname**表示当前文件所在目录，文件路径加上这个就可以解决问题。注意后面的”/“字符是需要的.</p>
<p>注意：这样的路径拼接实际上就是字符串拼接出路径，因此写的时候字符串的格式要和路径一样，而不是像path.join方法按照路径的格式写，所以下面的file前面是/而不是./</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(__dirname+<span class="string">&#x27;/file/1.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,dataStr</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败！&#x27;</span>+err.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取成功&#x27;</span>+dataStr);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-Path路径模块"><a href="#3-Path路径模块" class="headerlink" title="3. Path路径模块"></a>3. Path路径模块</h2><p>path模块是Node.js官方提供的，用来处理路径的模块。它提供了一系列方法和属性，用来满足用户对路径的处理需求。</p>
<h3 id="1-导入path"><a href="#1-导入path" class="headerlink" title="1. 导入path"></a>1. 导入path</h3><p>const path=require (‘path’)</p>
<h3 id="2-路径拼接path-join"><a href="#2-路径拼接path-join" class="headerlink" title="2. 路径拼接path.join"></a>2. 路径拼接path.join</h3><p>path.join(str1, str2, str3,…)</p>
<p>返回字符串，以路径格式。</p>
<p>会自动转换../ 和./ 。注意/在开头的字符串和后面的字符串有不同表现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pathStr= path.<span class="title function_">join</span>(<span class="string">&#x27;/a&#x27;</span>, <span class="string">&#x27;/b/c&#x27;</span>, <span class="string">&#x27;../&#x27;</span>, <span class="string">&#x27;./d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"><span class="comment">//../退回上级，因此自动抵消了/b/c中的/c，从/c返回上级; 最后的文件也不用加上./，会自动添加\</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathStr);<span class="comment">//\a\b\d\e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除扩展名</span></span><br><span class="line"><span class="keyword">const</span> pathStr2= path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./files/1.txt&#x27;</span>)；</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathStr); <span class="comment">//当前文件所处目录\files\1.txt</span></span><br></pre></td></tr></table></figure>

<h3 id="3-path-basename-获取路径中的文件名"><a href="#3-path-basename-获取路径中的文件名" class="headerlink" title="3. path.basename()获取路径中的文件名"></a>3. path.basename()获取路径中的文件名</h3><p>path.basename(fpath);//输出路径中的文件名，带有后缀名</p>
<p>path.basename(fpath, postfix)； //输出文件名，不带后缀</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fpath=<span class="string">&#x27;/a/b/c/index.html&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> fullName=path.<span class="title function_">basename</span>(fpath); <span class="comment">//index.html</span></span><br><span class="line"><span class="keyword">var</span> nameWithoutExt=path.<span class="title function_">basename</span>(fpath,<span class="string">&#x27;.html&#x27;</span>); <span class="comment">//index</span></span><br></pre></td></tr></table></figure>

<h3 id="4-path-extname-获取路径中的扩展名"><a href="#4-path-extname-获取路径中的扩展名" class="headerlink" title="4. path.extname()获取路径中的扩展名"></a>4. path.extname()获取路径中的扩展名</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fpath=<span class="string">&#x27;/a/b/c/index.html&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> fext=path.<span class="title function_">extname</span>(fpath);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fext);<span class="comment">//.html</span></span><br></pre></td></tr></table></figure>

<h3 id="5-时钟案例"><a href="#5-时钟案例" class="headerlink" title="5. 时钟案例"></a>5. 时钟案例</h3><p>一个html文件中有script和style标签，script标签中可以引用js文件，style标签中可以有css和html内容。因此，可以根据正则匹配先找出script和style标签中的内容，然后使用path路径中的方法获取其中的指定扩展名文件。</p>
<ol>
<li>步骤一</li>
</ol>
<p>定义标签<style></style>和<script></script>的正则表达式</p>
<p>\s表示空白字符，\S表示非空白字符 。注意反标签里的/需要使用转义字符\，否则就和/匹配了</p>
<p>/<style>[\s\S]*&lt;/style&gt;/  </p>
<p>/<script>[\s\S]*</script>/ </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入fs和path模块</span></span><br><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">//2.定义正则表达式分别匹配style和script标签</span></span><br><span class="line"><span class="keyword">const</span> regStyle=<span class="regexp">/&lt;style&gt;[\s\S]*&lt;\/style&gt;/</span>  ;</span><br><span class="line"><span class="keyword">const</span> regScript = <span class="regexp">/&lt;script&gt;[\s\S]*&lt;\/script&gt;/</span> ;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>步骤二</li>
</ol>
<p>使用fs模块读取需要被处理的html文件，拆解出其中的css，js文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 调用fs.readFile方法读取文件</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;../stuff/index.html&#x27;</span>),<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,dataStr</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败&#x27;</span>+err.<span class="property">message</span>);</span><br><span class="line">    <span class="comment">//4.读取成功后，调用对应的三个方法分别拆解出css，js，html文件</span></span><br><span class="line">    <span class="title function_">resolveCSS</span>(htmlStr);</span><br><span class="line">    <span class="title function_">resolveJS</span>(htmlStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li> 步骤三</li>
</ol>
<p>自定义resoleveCSS方法，从html字符串中取出css文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveCSS</span>(<span class="params">htmlStr</span>)&#123;</span><br><span class="line">    <span class="comment">//利用正则表达式取出style标签</span></span><br><span class="line">    <span class="keyword">const</span> r1=regStyle.<span class="title function_">exec</span>(htmlStr);<span class="comment">//数组【0】项为style标签内容</span></span><br><span class="line">    <span class="comment">//提取style标签中的字符串内容</span></span><br><span class="line">    <span class="keyword">const</span> newCSS = r1[<span class="number">0</span>].<span class="title function_">replace</span>(<span class="string">&#x27;&lt;style&gt;&#x27;</span>,<span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;&lt;/style&gt;&#x27;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="comment">//调用fs.writeFile()方法，将提取的样式写入到自建的clock目录中的index.css文件 </span></span><br><span class="line">    fs.<span class="title function_">writeFile</span>(path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./clock/index.css&#x27;</span>),newCSS,<span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入CSS失败&#x27;</span>+err.<span class="property">message</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入css成功&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>步骤四</li>
</ol>
<p>自定义resolve JS方法写入js文件。通过正则提取对应的script内容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveJS</span>(<span class="params">htmlStr</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> r2 = regStr.<span class="title function_">exec</span>(htmlStr);</span><br><span class="line">    <span class="keyword">const</span> newJS=r2[<span class="number">0</span>].<span class="title function_">replace</span>(<span class="string">&#x27;&lt;script&gt;&#x27;</span>,<span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;&lt;/script&gt;&#x27;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    fs.<span class="title function_">writeFile</span>(path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./clock/index.js&#x27;</span>),newJS,<span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入Javascript脚本失败&#x27;</span>+err.<span class="property">message</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入JS文件成功&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>步骤五</li>
</ol>
<p>将原来的JS和css内容写成外嵌的js，css标签。</p>
<p>直接用正则表达式将script标签和style标签进行替换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveHTML</span>(<span class="params">htmlStr</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> newHTML= htmlStr.<span class="title function_">replace</span>(regStyle, <span class="string">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;/&gt;&#x27;</span>).<span class="title function_">replace</span>(regScript,<span class="string">&#x27;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&#x27;</span>);</span><br><span class="line">     fs.<span class="title function_">writeFile</span>(path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./clock/index.html&#x27;</span>),newHTML,<span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入HMTL失败&#x27;</span>+err.<span class="property">message</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入HTML文件成功&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-http模块"><a href="#4-http模块" class="headerlink" title="4. http模块"></a>4. http模块</h2><p>http模块是node.js官方提供，用来创建web服务器的模块。通过http模块提供的)方法，http.createServer()，可以方便地将一台电脑变为服务器，从而对外提供web资源服务。服务器与普通电脑的区别就在于安装了web服务器软件。</p>
<p><strong>ip地址和域名一一对应</strong>，对应关系存放在域名服务器（ＤＮＳ）中。通过端口号可以准确地将网络请求交给对应的ｗｅｂ服务进行处理，<strong>每个端口号只能对应一个ｗｅｂ服务</strong>，实际应用中的<strong>８０</strong>端口可以被省略。</p>
<h3 id="创建最基本的web服务器"><a href="#创建最基本的web服务器" class="headerlink" title="创建最基本的web服务器"></a>创建最基本的web服务器</h3><ol>
<li>导入http模块</li>
</ol>
<p>const http=<strong>require</strong>(‘http’)；</p>
<ol start="2">
<li>创建web服务器实例</li>
</ol>
<p>const server = http.createServer();</p>
<ol start="3">
<li>为服务器实例绑定request事件</li>
</ol>
<p>为服务器实例绑定<strong>request</strong>事件，可监听客户端发送过来的网络请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用服务器实例的on方法，为服务器绑定request事件</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//只要客户端请求服务器，就会触发request事件，从而调用这个事件的处理函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;welcome&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>启动服务器</li>
</ol>
<p>调用服务器实例的.<strong>listen</strong>方法，启动当前的web服务器实例。指定运行端口.</p>
<p>此时可以通过127.0.0.1访问服务器，就会向服务器发送request请求，触发回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http server running at http://127.0.0.1：80&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="req请求对象"><a href="#req请求对象" class="headerlink" title="req请求对象"></a>req请求对象</h3><p>只要服务器接收到客户端请求，就会通过server.on()方法调用为服务器绑定的request事件处理函数。如果想在事件处理函数中访问与客户端相关的数据或属性，就可以使用req对象。</p>
<p>req对象：包含与客户端相关的数据或属性。</p>
<p>req.url:客户端<strong>请求</strong>的URL地址</p>
<p>req.method：客户端的method请求类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url=req.<span class="property">url</span>;</span><br><span class="line">    <span class="keyword">const</span> method=req.<span class="property">method</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="res响应对象"><a href="#res响应对象" class="headerlink" title="res响应对象"></a>res响应对象</h3><p>res对象：包含与服务器相关的数据或属性，包括向客户端想要发送的字符串</p>
<p>**res.end()**：向客户端发送指定的内容，并结束此次请求的处理过程。(结束请求不是结束服务器)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url=req.<span class="property">url</span>;</span><br><span class="line">    <span class="keyword">const</span> method=req.<span class="property">method</span>;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;url is $&#123;url&#125;, adn method is $&#123;method&#125;&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>为了防止中文显示乱码的问题，需要设置响应头<strong>content-type</strong>的值为<strong>text/html；charset=utf-8;</strong></p>
<p>使用<strong>setHeader</strong>(‘content-Type’, ‘text/html;charset=utf-8’)方法式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url=req.<span class="property">url</span>;</span><br><span class="line">    <span class="keyword">const</span> method=req.<span class="property">method</span>;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;url is $&#123;url&#125;, adn method is $&#123;method&#125;&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="根据不同url响应不同html内容"><a href="#根据不同url响应不同html内容" class="headerlink" title="根据不同url响应不同html内容"></a>根据不同url响应不同html内容</h3><ol>
<li>获取请求的url地址</li>
<li>设置默认内容为404 not found</li>
<li>判读请求的url是否为’/‘或/index.html页面</li>
<li>判断url是否为/about.html页面</li>
<li>设置content-type响应头，防止返回的中文乱码</li>
<li>使用res.end将内容响应给客户端</li>
</ol>
<p>测试输入地址时，IP为127.0.0.1，后面的页面可以随便加，比如<a target="_blank" rel="noopener" href="http://127.0.0.1/index.html">http://127.0.0.1/index.html</a> 或<a target="_blank" rel="noopener" href="http://127.0.0.1/about.html">http://127.0.0.1/about.html</a> ；前者ip发送的url是’/‘，后面两者是’/index.html’。因为浏览器不知道你是否有这些页面啊，所以管不了它怎么写，只能拿过来进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params">req,res </span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> url=req.<span class="property">url</span>;</span><br><span class="line">    <span class="keyword">const</span> method=req.<span class="property">method</span>;</span><br><span class="line">    <span class="keyword">let</span> content =<span class="string">&#x27;&lt;h1&gt;404&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(url===<span class="string">&#x27;/&#x27;</span>||url===<span class="string">&#x27;/index.html&#x27;</span>)&#123;</span><br><span class="line">        content=<span class="string">&#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url===<span class="string">&#x27;/about.html&#x27;</span>)&#123;</span><br><span class="line">        content=<span class="string">&#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">    res.<span class="title function_">end</span>(content);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-模块化"><a href="#5-模块化" class="headerlink" title="5. 模块化"></a>5. 模块化</h2><h3 id="1-模块化的概念"><a href="#1-模块化的概念" class="headerlink" title="1. 模块化的概念"></a>1. 模块化的概念</h3><p>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、可分解、可更换的单元。</p>
<p>模块化的好处</p>
<ol>
<li>复用性</li>
<li>可维护性</li>
<li>按需加载</li>
</ol>
<p>模块化规范：对代码进行模块化的拆分和组合时需要遵守的规则。比如是用什么样的语法格式引用模块，和对外暴露模块成员。</p>
<h3 id="2-Node-js中的模块化"><a href="#2-Node-js中的模块化" class="headerlink" title="2. Node.js中的模块化"></a>2. Node.js中的模块化</h3><p>Node.js根据模块来源的不同，将模块分为三大类：</p>
<ol>
<li>内置模块：Node.js官方提供的，如fs、path、http等</li>
<li>自定义模块：<strong>用户创建的每个.js文件，都是自定义模块</strong></li>
<li>第三方模块: 第三方开发的模块，使用前需要提前下载</li>
</ol>
<h3 id="3-加载模块"><a href="#3-加载模块" class="headerlink" title="3. 加载模块"></a>3. 加载模块</h3><ol>
<li>加载内置模块：const fs=require(‘fs’);</li>
<li>加载用户的自定义模块（需要<strong>提供路径</strong>）：const custom= require(‘./custom.js’)</li>
<li>加载第三方模块： const moment= require(‘moment’)</li>
</ol>
<p>注意：自定义模块可以省略后缀名，但一定不能省略路径，当前目录也不能省略’./‘</p>
<p>使用require加载其它模块时，会执行被加载模块中的代码。比如自定义了模块.js，其他文件的代码使用require加载它时，会立即执行该.js文件中的代码。</p>
<h3 id="4-模块作用域"><a href="#4-模块作用域" class="headerlink" title="4. 模块作用域"></a>4. 模块作用域</h3><p>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块被访问，这种模块级别的访问限制，叫做模块作用域。模块作用域可以防止全局变量污染。如果是引入js文件如<script src='kk.js'></script>，kk.js文件中的全局变量可以被引用它的文件获取。</p>
<h3 id="5-共享模块作用域中的成员"><a href="#5-共享模块作用域中的成员" class="headerlink" title="5. 共享模块作用域中的成员"></a>5. 共享模块作用域中的成员</h3><ol>
<li>module对象</li>
</ol>
<p>每个.js自定义模块中都有一个module对象，里面存储了和当前模块有关的信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在js文件中定义一行代码console.log(module)；</span></span><br><span class="line"><span class="comment">//会打印如下内容</span></span><br><span class="line"><span class="title class_">Module</span> &#123;<span class="attr">id</span>: <span class="string">&#x27;.&#x27;</span>, <span class="attr">path</span>: <span class="string">&#x27;g:\frontend&#x27;</span>, <span class="attr">exports</span>: &#123;…&#125;, <span class="attr">parent</span>: <span class="literal">null</span>, <span class="attr">filename</span>: <span class="string">&#x27;g:\frontend\Module.js&#x27;</span>, …&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>module.exports对象</li>
</ol>
<p>在自定义模块中，可以使用module.exports对象，将模块内的成员共享出去，供外界成员使用。外界成员使用require导入模块时，接收到的就是module.exports对象。默认情况为空对象{}</p>
<p>模块中添加module.exports对象成员就把exports当作一个对象就好，可以直接添加属性（挂载属性），也可以将对象赋给exports。但是如果同时用两种方法，module.exports会以指向的对象为准。就是说：<br>前面是添加对象属性（挂载属性），但是后面如果有赋值对象（指向对象），前面添加的对象属性都不会算数，而复制对象后面添加的对象属性会加入exports对象中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;232&#x27;</span>,</span><br><span class="line">    <span class="attr">say</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;23&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">name</span>=<span class="string">&#x27;23&#x27;</span>;<span class="comment">//修改属性成功，传出去的是修改后的name=23而不是232</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">say</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">name</span>=<span class="string">&#x27;23&#x27;</span>;<span class="comment">//传出去的是修改后的name=23而不是232</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">age</span>=<span class="number">55</span>;<span class="comment">//因为后面有赋值属性，不算数</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">say</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;  <span class="comment">//不算数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;232&#x27;</span>,        <span class="comment">//传出去的是name=232而不是23也没有age，因为被这个赋值的对象覆盖了</span></span><br><span class="line">    <span class="attr">say</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;23&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>exports对象</li>
</ol>
<p>为了简化向外共享成员的代码，Node提供了exports对象，默认情况下，exports和module.exports指向同一个对象，但<strong>最终共享结果依然以module.exports指向对象</strong>为准。也就是说没写module.exports的话，用exports就会把exports对象共享出去，使用实践如下：</p>
<ul>
<li>exports不能有赋值对象，直接赋值对象不算数，只能添加对象属性</li>
<li>exports可以和module.exorts共用，前提是module.exports也是添加对象属性，一旦module.exports有赋值对象，所有的exports添加对象都不算数，无论在前在后</li>
<li>原理：其实就是两个exports本来指向的是同一个{}，只要其中一个指向了新对象，而始终以module.lexports指向对象为准，那么就会出现上述问题。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果没写exports</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">exports</span>===<span class="variable language_">module</span>.<span class="property">exports</span>); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//写了exports</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">exports</span>===<span class="variable language_">module</span>.<span class="property">exports</span>);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="6-CommonJs对象"><a href="#6-CommonJs对象" class="headerlink" title="6. CommonJs对象"></a>6. CommonJs对象</h3><p>Node.js遵循CommonJS规范，CommonJS规定了模块的特性和模块之间如何相互依赖：</p>
<ol>
<li>每个模块内部，module变量代表当前模块</li>
<li>module变量是一个对象，它的exports属性是对外接口</li>
<li>加载某个模块，其实是加载该模块的module.exports属性，require方法用于加载模块</li>
</ol>
<h2 id="6-npm与包"><a href="#6-npm与包" class="headerlink" title="6. npm与包"></a>6. npm与包</h2><h3 id="包："><a href="#包：" class="headerlink" title="包："></a>包：</h3><p>Node,js中的第三方模块被称为包。</p>
<p>因为内置模块提供的一些底层API，项目开发时效率很低。包是基于内置模块封装出来的们提供了更高效的API，提高开发效率。</p>
<p><a target="_blank" rel="noopener" href="https://www.npmjs.com/%E5%8F%AF%E4%BB%A5%E6%90%9C%E7%B4%A2%E5%88%B0%E6%89%80%E6%9C%89npm%E5%8C%85%E3%80%82https://registsry.npmjs.org/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E5%8C%85%E3%80%82">https://www.npmjs.com/可以搜索到所有npm包。https://registsry.npmjs.org/服务器下载包。</a></p>
<p>包管理工具Node Package manager:npm包管理工具</p>
<h3 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h3><p>通过两种格式化时间方法体会为什么npm高效</p>
<ul>
<li>传统方法：自己写</li>
</ul>
<p>工具类js模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dateFormat</span>(<span class="params">dataStr</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dt=<span class="keyword">new</span> <span class="title class_">Date</span>(dataStr);</span><br><span class="line">    <span class="keyword">const</span> y = <span class="title function_">padZero</span>(dt.<span class="title function_">getFullYear</span>());</span><br><span class="line">    <span class="keyword">const</span> m=<span class="title function_">padZero</span>( dt.<span class="title function_">getMonth</span>()+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> d=<span class="title function_">padZero</span>(dt.<span class="title function_">getDate</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hh= <span class="title function_">padZero</span>(dt.<span class="title function_">getHours</span>());</span><br><span class="line">    <span class="keyword">const</span> mm = <span class="title function_">padZero</span>(dt.<span class="title function_">getMinutes</span>());</span><br><span class="line">    <span class="keyword">const</span> ss =<span class="title function_">padZero</span>(dt.<span class="title function_">getSeconds</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y+<span class="string">&#x27;-&#x27;</span>+m+<span class="string">&#x27;-&#x27;</span>+d+<span class="string">&#x27;  &#x27;</span>+hh+<span class="string">&#x27;:&#x27;</span>+mm+<span class="string">&#x27;:&#x27;</span>+ss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padZero</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> n&gt;<span class="number">9</span>? <span class="attr">n</span>:<span class="string">&#x27;0&#x27;</span>+n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">dateFormat</span>=dateFormat;</span><br></pre></td></tr></table></figure>

<p>调用js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> form=<span class="built_in">require</span>(<span class="string">&#x27;./dataFormat&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(form.<span class="title function_">dateFormat</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br></pre></td></tr></table></figure>

<ul>
<li>使用npm的moment包对时间格式化</li>
</ul>
<ol>
<li>安装包</li>
</ol>
<p>npm install / i 包的完整名称</p>
<ol start="2">
<li>导入第三方包，导入名称即安装包时的名称</li>
</ol>
<p>const moment = require(‘moment’);</p>
<ol start="3">
<li>按照官方文档使用第三方包，它的方法和参数都说得清清楚楚</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moment=<span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">moment</span>().<span class="title function_">format</span>(<span class="string">&#x27;YY-M-D HH:mm:ss&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><p>装包之后就会在项目文件夹下出现node_modules的文件夹（存放所有安装到项目中的包，require时从这里查找和导入包）和package-lock.json的配置文件（包含包的配置信息如版本等）。不要手动这修改些文件中的任何代码，npm包管理工具会自动维护。</p>
<p>安装指定版本的包：默认安装最新的包</p>
<p>npm install 包名@版本</p>
<p>包的语义化版本规范：大版本（底层重构）.功能版本（新增功能）.bug修复版本</p>
<h3 id="package-json配置文件"><a href="#package-json配置文件" class="headerlink" title="package.json配置文件"></a>package.json配置文件</h3><p>package.json在创建好项目目录后就创建好，一定要在<strong>项目根目录</strong>中，记录了安装包的相关信息。共享GitHub代码时不需要上传npm中这种共享包，将安装的包添加到gitnone忽略文件中。</p>
<ol>
<li>快速创建package.json：npm init -y 在执行该命令时所处的目录中快速创建package.json包管理配置文件，目录中不能有中文。</li>
</ol>
<p>难怪可以用npm run 项目名来运行项目！！还可以用npm install安装jquery？？</p>
<ol start="2">
<li>dependencies节点：记录使用npm install命令安装了哪些包。执行npm insatll命令时，npm包管理工具会先读取package.json中的dependencies节点，从中获得所有依赖包名称和版本号之后，一次性下载这些package.json中记录的所有包</li>
<li>卸载包：npm uninstall 包名</li>
<li>devDependencies节点：开发阶段用到但项目上线之后不会用到的包记录在devDependencies节点中，如webpack；开发和上线都会用到的包加到dependencies</li>
</ol>
<p>npm i 包名 -D  安装指定的包，并记录到devDependencies节点中</p>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>文件存储形式，一个磁盘的数据在另一个磁盘上存在一个完全相同的副本即为镜像。</p>
<p>下包镜像源：下包的服务器地址</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看当前的下包镜像源</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="comment">//切换下包镜像源</span></span><br><span class="line">npm config set registry=<span class="attr">https</span>:<span class="comment">//registry.npm.taobao.org/</span></span><br></pre></td></tr></table></figure>

<h3 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h3><p>利用nrm提供对终端命令，可以快速查看和切换下载的镜像源</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装nrm</span></span><br><span class="line">npm i nrm -g</span><br><span class="line"><span class="comment">//查看所有可用的镜像源</span></span><br><span class="line">nrm ls</span><br><span class="line"><span class="comment">//将下包的镜像源切换为taobao镜像</span></span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure>

<h3 id="全局包"><a href="#全局包" class="headerlink" title="全局包"></a>全局包</h3><p>执行npm install 包名 -g 安装全局包，下载路径在C:\users\用户目录\Appdata\Roaming\npm\node_modules目录。</p>
<p>卸载：npm uninstall 包名 -g</p>
<p>只有工具性质的包才有全局安装的必要，如nrm。是否需要全局安装参考官方文档的包说明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装全局包i5ting_toc</span></span><br><span class="line">npm install -g i5ting_toc</span><br><span class="line"><span class="comment">//调用i5ting_toc，将md转为html</span></span><br><span class="line">i5ting_toc -f md文件路径 -o</span><br></pre></td></tr></table></figure>

<h3 id="包的内部结构"><a href="#包的内部结构" class="headerlink" title="包的内部结构"></a>包的内部结构</h3><ul>
<li>包必须以<strong>单独的目录</strong>存在</li>
<li>包的顶级目录下必须有package.json包管理配置文件</li>
<li>package.json必须有name，version，main三个属性，分别代表包名（就是目录名），版本号，包的入口</li>
</ul>
<p>main：require包时，在package.json找到main属性，告诉应该导入的文件</p>
<h3 id="开发自己的包"><a href="#开发自己的包" class="headerlink" title="开发自己的包"></a>开发自己的包</h3><p>初始化包的基本结构：</p>
<ol>
<li>新建文件夹作为包的根目录</li>
<li>在根目录中，新建如下三个文件<ul>
<li>package.json：包管理配置文件</li>
<li>index.js：包的入口文件</li>
<li>README.md：包的说明文档</li>
</ul>
</li>
<li>初始化package.json<ul>
<li>name：包名。package.json所在目录名</li>
<li>version：版本号</li>
<li><strong>main：包的入口。外界require包时应该加载的文件</strong></li>
<li>description：包提供了哪些功能的字符串</li>
<li>keywords：搜索关键字</li>
<li>license：包遵循的开源协议，默认“ISC”</li>
</ul>
</li>
<li>编写index.js文件。和模块文件一样，都需要<strong>module.exports对象</strong>。但是有了package.json文件定义了包的入口之后，不用再导入模块的路径，而导入包的路径即可调用index.js文件中的方法。</li>
<li>按功能拆分模块。可以将不同功能写入不同js文件中，然后在index.js中导入各个模块（require），再用module.exports将功能方法共享出去。</li>
</ol>
<p>index中exports对象可以使用es6的新特性**…对象**展开对象中的所有属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date =<span class="built_in">require</span>(<span class="string">&#x27;./dateFormat&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> escapte= <span class="built_in">require</span>(<span class="string">&#x27;./htmlEscape&#x27;</span>);</span><br><span class="line"><span class="comment">//向外暴露需要的成员</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">	...date,</span><br><span class="line">    ...<span class="built_in">escape</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>readme文档</li>
</ol>
<p>包的使用说明文档。这里包含安装方式、导入方式、格式化时间、开源协议等</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 文字说明</span><br><span class="line">```js</span><br><span class="line">	js代码内容</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="发布npm包"><a href="#发布npm包" class="headerlink" title="发布npm包"></a>发布npm包</h3><ol>
<li>注册npm账号</li>
<li>将npm包下载地址设置回npm包官方下载地址</li>
<li>登录：npm login</li>
<li>终端切换到包的根目录，执行npm publish命令，发布包，包名不能和已有包名相同。</li>
<li>删除已发布的包：npm unpublish 包名–force，只能删除72h以内发布的包</li>
</ol>
<h3 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h3><p>模块第一次加载后会被缓存，多次调用require（）并不会导致模块的代码被多次执行。</p>
<p>内置模块加载机制</p>
<p>内置模块加载优先级最高，如果第三方模块与内置模块冲突，则返回的始终是内置模块。</p>
<p>自定义模块加载机制</p>
<p>自定义模块（包）加载必须要<strong>加上路径./或../</strong> ，否则会当成内置或者第三方模块进行加载 ；使用require导入自定义模块，如果省略了文件扩展名，Node.js会按顺序加载以下文件：</p>
<ol>
<li>按照确切文件名加载</li>
<li>补全.js扩展名加载</li>
<li>补全.json扩展名加载</li>
<li>补全.node扩展名加载</li>
</ol>
<p>第三方模块加载机制</p>
<p>当require的参数不是内置模块，也不是以./或../开头，Node.js会从当前模块的父目录开始，尝试从**/node_modules**文件夹中加载第三方模块，如果没有找到，则移动到上一层父目录中，直到文件系统的根目录。</p>
<p>目录作为模块的加载机制</p>
<p>比如自定义的未发布的包，在某个目录中，还有package.json等配置文件。使用require进行加载时有三种加载方式。</p>
<ol>
<li>在被加载的目录中查找一个叫<strong>package.json</strong> 的文件，并寻找<strong>main属性</strong>作为require加载的入口</li>
<li>没有package.json文件，或者main入口或main指向的文件不存在，Node.js会示图加载目录下的index.js文件</li>
<li>上述都失败之后，打印错误消息，报告模块缺失。可能会继续补全扩展名查找如上所说</li>
</ol>
<h2 id="7-express"><a href="#7-express" class="headerlink" title="7. express"></a>7. express</h2><p>Express是npm的第三方包，提供了创建web服务器的便捷方法。比内置的http更方便。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li>安装：npm i <a href="mailto:&#x65;&#120;&#112;&#114;&#x65;&#x73;&#115;&#x40;&#x34;&#46;&#49;&#55;&#x2e;&#49;">&#x65;&#120;&#112;&#114;&#x65;&#x73;&#115;&#x40;&#x34;&#46;&#49;&#55;&#x2e;&#49;</a></li>
<li>导入express：const express = require(‘express’)</li>
<li>创建web服务器：<strong>const app = express()</strong></li>
<li>调用app.listen（端口号，启动成功后的回调函数）启动服务器:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;express server running at ...&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>监听GET请求</li>
</ol>
<p>**app.get()**方法，监听客户端的GET请求.</p>
<p>参数一：客户端请求去的URL地址</p>
<p>参数二：ｒｅｑ：请求对象包含于请求有关的属性与方法；res：包含于响应有关的响应对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;用户请求url&#x27;</span>, <span class="keyword">function</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">    <span class="comment">//处理函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>监听POST请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;请求url&#x27;</span>,<span class="keyword">function</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">    <span class="comment">//处理函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>把内容响应给客户端</p>
</li>
</ol>
<p>**res.send()**将处理好的内容发送给客户端</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送json对象</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="keyword">function</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">   res.<span class="title function_">send</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;za&#x27;</span>,<span class="attr">age</span>:<span class="number">34</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//发送字符串</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/user&#x27;</span>,<span class="keyword">function</span>(<span class="params">req,res</span>)&#123; </span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;请求成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>获取URL中携带的查询参数</li>
</ol>
<p>通过<strong>req.query</strong>对象，访问到客户端通过查询字符串的形式，发送到服务器的参数。</p>
<p>查询字符串格式：url后面加上’?param=value&amp;param1=value1’ 。</p>
<p>访问：req.query.param。默认情况下req.query对象为空对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>);  <span class="comment">//&#123;param:value,param1:value1&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>获取url中的动态参数</li>
</ol>
<p>通过<strong>req.params</strong>对象可以访问到URL中的通过**’:’** 匹配到的动态参数，动态参数名自己取。这样用户输入的url和我写的这个url格式应该一一对应的匹配，而不是像?可以匹配到根目录</p>
<p>这里的参数字符串格式为url+’/value’，这个url中的value直接与方法中的动态参数:后面的参数匹配</p>
<p>params中存放着匹配到的动态参数的值。动态参数可以有多个匹配</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user/:id/:name&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">params</span>); <span class="comment">//&#123;id:value&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><ol>
<li><strong>express.static()<strong>可以非常方便地创建一个</strong>静态资源服务器</strong>，提供对外访问某个目录下的图片、css文件、js文件等静态资源的<strong>访问路径</strong>。这些路径中不会包括目录名。通过路径直接获取到资源，比如如果访问的是静态页面html，那么直接显示html页面内容</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;./public&#x27;</span>))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>访问：</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://localhost:3000/images/bg.png">http://localhost:3000/images/bg.png</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:3000/index.css">http://localhost:3000/index.css</a></p>
<ol start="3">
<li>托管多个静态资源：多次调用static方法即可。如果不同资源目录中有相同命名的资源，则按照调用的先后顺序进行访问。</li>
<li>挂载路径前缀：</li>
</ol>
<p>如果希望在托管的静态资源访问路径前挂载路径前缀，可以使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/public&#x27;</span>,express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>就可以使用带目录名的url访问资源：<a href="http://localhost:3000./public/images/kitten.phg">http://localhost:3000./public/images/kitten.phg</a></p>
<h3 id="Nodemon"><a href="#Nodemon" class="headerlink" title="Nodemon"></a>Nodemon</h3><p>Nodemon可以监听项目文件的变动，当代码被修改后，nodemon会自动重启项目。</p>
<p>安装nodemon：项目根目录下运行npm i -g nodemon</p>
<p>使用nodemon：nodemon node.js文件名</p>
<h3 id="express路由"><a href="#express路由" class="headerlink" title="express路由"></a>express路由</h3><p>在Express中，路由指<strong>客户端请求与服务器处理函数</strong>之间的映射关系。</p>
<p>Express路由由<strong>请求类型、请求URL地址、处理函数</strong>三部分组成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">METHOD</span>(<span class="variable constant_">PATH</span>,<span class="variable constant_">HANDLER</span>)</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;用户请求url&#x27;</span>, <span class="keyword">function</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">    <span class="comment">//处理函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>路由匹配过程</p>
<p>每当一个请求到达服务器之后，需要先经过路由的匹配（请求类型和请求的URL），匹配成功之后才会调用对应的处理函数。按照路由（多个时）的定义先后顺序进行匹配请求类型和URL。比如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">web.<span class="title function_">get</span>(<span class="string">&#x27;/user/:we&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;hhhh&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">web.<span class="title function_">get</span>(<span class="string">&#x27;/user/2&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;hh&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//http//:localhost: 80/user/2 匹配情况根据以上两个先后顺序而定</span></span><br></pre></td></tr></table></figure>

<p>路由模块</p>
<p>**express.Router()**为方便对路由进行模块化管理，Express不建议将路由直接挂载到app上，而是将路由抽离为单独的模块。</p>
<p><strong>创建路由模块步骤</strong>：</p>
<ol>
<li>创建路由模块对应的.js文件</li>
<li>调用express.Routerr()函数创建路由对象</li>
<li>向路由对象挂载具体的路由</li>
<li>使用module.exports对外共享路由对象</li>
<li>使用app.use()函数注册路由模块</li>
</ol>
<p>以上是创建单个js文件模块的步骤，如果想要创建一个router包，就可以像上面创建包一样，就是很多项目中用到的路由的包！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由模块js文件</span></span><br><span class="line"><span class="comment">//导入express.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//创建路由对象</span></span><br><span class="line"><span class="keyword">var</span> router=express.<span class="title class_">Router</span>();</span><br><span class="line"><span class="comment">//挂载get方法路由</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/user/list&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Get user list&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/user/add&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Add user&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//http://localhost:3000/user/list</span></span><br><span class="line"><span class="comment">//向外导出路由对象</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<p><strong>使用路由模块步骤</strong></p>
<ol>
<li>导入路由模块，和导入某块方法一样</li>
<li>使用**app.use()**注册路由模块</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器js文件</span></span><br><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> web= <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">//导入路由模块</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./router&#x27;</span>)</span><br><span class="line"><span class="comment">//使用use方法注册模块</span></span><br><span class="line">web.<span class="title function_">use</span>(router);</span><br><span class="line">web.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;express running&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>app.use函数作用：注册全局中间件</p>
<p><strong>为路由模块添加前缀</strong></p>
<p>与添加静态资源路由前缀方法类似。app.use(‘/前缀名’, 路由模块)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>,router)</span><br><span class="line"><span class="comment">//以后访问路由都要加上api才能访问成功   http://localhost:3000/api/user/list</span></span><br></pre></td></tr></table></figure>

<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件指的是业务处理中的中间环节，上一个业务的输入作为下一个业务的输出。当一个请求到达Express的服务器之后，可以连续调用多个中间件，从而对这次请求进行<strong>预处理</strong>。</p>
<p>Express中间件格式，本质上是一个function处理函数。中间件函数的形参列表中，必须包含<strong>next函数</strong>参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="keyword">function</span>(<span class="params">req,res,next</span>)&#123;</span><br><span class="line">	<span class="title function_">next</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>next函数：实现多个中间件连续调用的关键，表示把流转关系转交给下一个中间件或路由。</p>
<p>中间件1–&gt;next——&gt;中间件2——&gt;中间件3</p>
<p><strong>定义中间件函数</strong></p>
<p>一定要有next</p>
<p>最简单的。当前中间件业务处理完毕后，必须调用next()函数，表示把流转关系转交给下一个中间件或路由。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量mw所指向的，是一个中间件函数</span></span><br><span class="line"><span class="keyword">const</span> mw = <span class="keyword">function</span>(<span class="params">req,res,next</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是一个最简单的中间件函数&#x27;</span>);</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>全局生效的中间件</strong></li>
</ol>
<p>客户端发起的<strong>任何请求</strong>，到达服务器之后，<strong>都会触发中间件</strong> ，这样的叫做全局生效的中间件。</p>
<p>通过调用app.use(中间件函数)，即可定义一个全局生效的中间件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(mw)</span><br></pre></td></tr></table></figure>

<p>可以使用app.use()连续定义多个全局中间件，客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用。不写next就无法执行下一个中间件</p>
<p><strong>中间件的作用</strong></p>
<p>多个中间件之间<strong>共享同一份req和res</strong>，这样上游中间件对rea或res对象添加自定义的属性或方法，都可以供下游的中间件或路由进行使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">req,res,next</span>)&#123;</span><br><span class="line">    req.<span class="property">startTime</span>=<span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是一个最简单的中间件函数&#x27;</span>);</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>局部生效的中间件</strong></li>
</ol>
<p>不使用app.use()定义的中间件，叫做局部生效的中间件。比如路由中添加中间件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mw中间件只能在/这个路由下面生效</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,mw ,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Home Page&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>局部路由中使用多个中间件</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两种等价</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,mw1,mw2，(req,res)=&gt;&#123;    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Home Page&#x27;</span>)&#125;)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,[mw1,mw2]，(req,res)=&gt;&#123;    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Home Page&#x27;</span>)&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ol>
<li><p>一定要在路由之前注册中间件（全局中间件放在路由之后就无法生效，但是如果是使用app.use()注册的路由且路由函数中有next（）函数或许可以，但是这样的请求必须要经过这么写的路由才行，其它就不行因为没有next，试过）。在路由前还是路由后是否执行都会看具体写在什么路由的情况，就像上面说的，其实就是一个根据不同函数特性的业务处理流程的问题。</p>
</li>
<li><p>客户端发送的请求可以连续调用多个中间件进行处理</p>
</li>
<li><p>中间件函数一定要记得调用next()函数，否则无法进行后续业务，局部生效的也一样，最后一个也要写，否则无法执行路由业务。（它的执行流程就是那样的，先是中间件然后一路next到最后处理路由业务，反正都要加上，难怪中间件要写在路由前面）</p>
</li>
<li><p>中间件的业务代码要写在next之前，否则无法执行</p>
</li>
<li><p>连续调用多个中间件时，多个中间件之前，共享req和res对象</p>
</li>
<li><p><strong>中间件的分类</strong></p>
<ol>
<li>应用级的中间件</li>
</ol>
<p>使用app.use()或app.get()或app.post()绑定到app实例上的中间件。</p>
<ol start="2">
<li>路由级别的中间件</li>
</ol>
<p>绑定到express.Router()实例上的中间件，叫做路由级别的中间件。与应用级别中间件的区别就是它绑定到routre实例上。router.use(function(req,res,next)=&gt;{})</p>
<ol start="3">
<li>错误级别的中间件</li>
</ol>
<p>专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。必须要有err参数。错误级别中间件必须注册在所有路由之后</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;   </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;服务器发生错误&#x27;</span>) <span class="comment">//抛出自定义的错误，定义错误消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Home Page&#x27;</span>); <span class="comment">//发生错误则无法执行。不要在这里处理错误</span></span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">err,req,res,next</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生了错误&#x27;</span>+err.<span class="property">message</span>); <span class="comment">//捕获错误，在服务器打印错误消息</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Error!&#x27;</span>+err.<span class="property">message</span>) <span class="comment">//向客户端响应错误相关内容</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>Express内置中间件</p>
<ul>
<li>express.static快速托管静态资源的内置中间件，无兼容性，在任何express版本都可以使用</li>
<li>express.json 解析JSON格式的请求体数据，仅在4.16后可以使用。如果没有配置这个，那么默认接收到的json格式就会被解析为undefined</li>
<li>express.urlencoded 解析URL-encoded格式（到底是个什么格式？？）的请求体数据，仅在4.16之后使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//json使用</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line"><span class="comment">//配置解析application/x-www-form-urlencoded格式表单数据的内置中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;))</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>第三方中间件</li>
</ol>
<p>非Express官方内置的又第三方开发的中间件，叫做第三方中间件。常用body-parser这个第三方中间件，用来解析请求体数据。使用：</p>
<ol>
<li>npm install body-parser安装中间件</li>
<li>require导入</li>
<li>app.use()注册并使用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(parser.<span class="title function_">urlencoded</span>(&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;))</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>自定义中间件</strong></p>
<p>模拟类似于express.urlencoded中间件，解析POST提交到服务器的表单数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用app.use定义解析表单数据的中间件</span></span><br><span class="line"><span class="comment">//导入Node.js内置的querystring模块</span></span><br><span class="line"><span class="keyword">const</span> qr=<span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">req,res,next</span>)&#123;</span><br><span class="line">	<span class="comment">//定义中间件具体业务逻辑</span></span><br><span class="line">     <span class="comment">//监听req对象的data事件（发送过来的数据可能不完整，需要我们拼接，每接收到一次发送过来的数据就处理一次）</span></span><br><span class="line">     <span class="keyword">let</span> str=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function">(<span class="params">chunk</span>)=&gt;</span>&#123;</span><br><span class="line">        str+=chunk;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//监听req的end事件。当拿到所有的数据后，触发req的end事件，处理拿到的完整请求体数据</span></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//在str中存放的是完整请求体数据</span></span><br><span class="line">        <span class="comment">//使用Node.js内置的querystring模块提供的parse()函数将字符串格式的请求体数据解析为对象格式，但是现在已经弃用</span></span><br><span class="line">        <span class="keyword">const</span> body = qs.<span class="title function_">parse</span>(str);</span><br><span class="line">        <span class="comment">//将解析出的数据挂载到req.body上供下游使用</span></span><br><span class="line">        req.<span class="property">body</span> = body;</span><br><span class="line">        <span class="title function_">next</span>(); <span class="comment">//next后才能交给路由进行处理</span></span><br><span class="line">    &#125;)</span><br><span class="line">   </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//绑定post请求</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/user&#x27;</span>,<span class="keyword">function</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(req.<span class="property">body</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>将自定义组件封装为模块：将定义的中间件函数通过module.exports共享出去，就不是对象形式了（？？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//custom.js模块</span></span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser=<span class="keyword">function</span>(<span class="params">req,res,next</span>)&#123;</span><br><span class="line">	<span class="comment">//定义中间件具体业务逻辑</span></span><br><span class="line">     <span class="comment">//监听req对象的data事件（发送过来的数据可能不完整，需要我们拼接，每接收到一次发送过来的数据就处理一次）</span></span><br><span class="line">     <span class="keyword">let</span> str=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function">(<span class="params">chunk</span>)=&gt;</span>&#123;</span><br><span class="line">        str+=chunk;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//监听req的end事件。当拿到所有的数据后，触发req的end事件，处理拿到的完整请求体数据</span></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//在str中存放的是完整请求体数据</span></span><br><span class="line">        <span class="comment">//使用Node.js内置的querystring模块提供的parse()函数将字符串格式的请求体数据解析为对象格式，但是现在已经弃用</span></span><br><span class="line">        <span class="keyword">const</span> body = qs.<span class="title function_">parse</span>(str);</span><br><span class="line">        <span class="comment">//将解析出的数据挂载到req.body上供下游使用</span></span><br><span class="line">        req.<span class="property">body</span> = body;</span><br><span class="line">        <span class="title function_">next</span>(); <span class="comment">//next后才能交给路由进行处理</span></span><br><span class="line">    &#125;)</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=bodyParser</span><br></pre></td></tr></table></figure>

<p>使用自定义组件模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> custompa=<span class="built_in">require</span>(<span class="string">&#x27;./custom.js&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(custompa);  <span class="comment">//不用写成函数调用的形式？？</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用Express编写接口"><a href="#使用Express编写接口" class="headerlink" title="使用Express编写接口"></a>使用Express编写接口</h3><p>前面创建的路由router模块就是api，main程序使用app.use(router)调用</p>
<p><strong>编写GET接口</strong></p>
<p>和前面router.get方法一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/get&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//通过req.query获取客户端通过查询字符串，发送到服务器的数据</span></span><br><span class="line">    <span class="keyword">const</span> query = req.<span class="property">query</span>;</span><br><span class="line">    <span class="comment">//调用res.send方法，返回服务器处理的结果</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">		<span class="attr">staus</span>:<span class="number">0</span>,<span class="comment">//处理成功</span></span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&#x27;get请求成功&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>:query</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>编写post接口</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/post&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//通过req.body获取客户端请求体中包含的url-encoded格式的数据</span></span><br><span class="line">    <span class="keyword">const</span> body = req.<span class="property">body</span>;</span><br><span class="line">    <span class="comment">//调用res.send方法，返回服务器处理的结果</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">		<span class="attr">staus</span>:<span class="number">0</span>,<span class="comment">//处理成功</span></span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&#x27;get请求成功&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>:body</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//需要在app.js中配置解析url-encoded表单数据的中间件。因为post不能直接将数据拼接在url中</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="cors跨域资源共享"><a href="#cors跨域资源共享" class="headerlink" title="cors跨域资源共享"></a>cors跨域资源共享</h3><p>JSONP仅支持get请求，使用CORS解决跨域问题。</p>
<p>使用CORS第三方中间件解决跨域问题</p>
<p>步骤：</p>
<ol>
<li>运行npm install cors安装中间件</li>
<li>使用const cors = require(‘cors’)导入中间件</li>
<li>在路由之前使用**app.use(cors())**调用中间件。注意这里的cors是中间件，所以是函数！要用cors()调用</li>
</ol>
<p><strong>什么是CORS</strong></p>
<p>CORS（crossing-origin resource sharing)跨域资源共享由一系列HTTP响应头组成，这些响应头决定浏览器是否阻止前端JS代码跨域获取资源。</p>
<p>浏览器的同源安全策略默认会组织网页“跨域”获取资源，但如果接口服务器配置了CORS相关的HTTP响应头（Access-control-allow），就可以接触跨域访问限制。</p>
<p>CORS主要在服务器端进行配置，客户端浏览器无须做任何额外配置。在浏览器中有兼容性。</p>
<p><strong>CORS响应头-Access-Control-Allow-Origin</strong></p>
<p>响应头部可以携带一个Access-Control-Allow-Origin字段，语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow: &lt;origin&gt; | *</span><br></pre></td></tr></table></figure>

<p>origin参数指定允许访问该资源的外域URL，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://itcase.cn&#x27;</span>)</span><br><span class="line"><span class="comment">//只允许来自http://itcast.cn的请求</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="comment">//通配符*表示允许来自任何请求的访问</span></span><br></pre></td></tr></table></figure>

<p><strong>CORS响应头- Access-Control-Allow-Headers</strong></p>
<p>默认情况下，cors仅支持客户端向服务器发送如下的9个请求头：</p>
<p>Accept、content-type等，如果客户端向服务器发送了额外的请求头信息，就需要在服务器端，通过Access-Control-Allow-Headers对额外的请求头进行声明，否则此次请求会失败</p>
<p>但是下面这些什么时候写上呢？？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许客户端向服务器发送content-type请求头和x-custom-header请求头</span></span><br><span class="line"><span class="comment">//多个请求头之间使用英文的逗号进行分割</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Content-Type, X-Custom-Header&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Cors响应头 Access-Control-Allow-Methods</strong></p>
<p>默认情况下，CORS仅支持客户端发起GET、PoST、HEAD请求</p>
<p>如果客户端希望通过PUT、DELETE等方式请求服务器的i资源，则需要在服务器端通过Access-Control-Allow-Methods指明实际请求所允许使用的HTTP方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;POST, GET, DELETE, HEAD&#x27;</span>)</span><br><span class="line"><span class="comment">//允许所有</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>CORS请求分类</strong></p>
<p>简单请求：</p>
<ol>
<li>请求方式：GET、POST、HEAD</li>
<li>HTTP头部信息不超过以下几种字段：无自定义头部字段、Accept等9种头部字段</li>
</ol>
<p>预检请求：符合以下任一个</p>
<ol>
<li>请求方式为出GET、POST、HEAD之外的请求Ｍｅｔｈｏｄ类型</li>
<li>请求头中包含自定义头部字段</li>
<li>向服务器发送了application/json格式的数据</li>
</ol>
<p>浏览器与服务器正式通信之前，浏览器会发送<strong>OPTION请求</strong>进行预检，以获知服务器是否允许该实际请求，OPTION请求称为预检请求。服务器成功响应预检请求之后，浏览器才会发送真正的请求并携带真实的数据。</p>
<p>简单请求：与服务器只发生一次请求；预检请求：OPTION请求成功之后才会发送真正的请求</p>
<h3 id="JSONP接口"><a href="#JSONP接口" class="headerlink" title="JSONP接口"></a>JSONP接口</h3><p>概念：浏览器端通过<script>标签的src属性请求服务器上的数据。同时，服务器返回一个函数的调用，这种请求数据的方式叫做JSONP</p>
<p>特点：</p>
<ol>
<li>JSONP并不是真正的Ajax请求，因为它没有使用XMLHttpRequest请求</li>
<li>JSONP仅支持GET请求</li>
</ol>
<p>如果项目中已经配置了CORS跨域资源共享，为防止冲突，必须在配置CORS中间件之前声明JSONP接口。否则JSONP接口会被处理成开启了CORS的接口。？？怎么理解</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优先创建JSONP接口，就不会被当成</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/jsonp&#x27;</span>, <span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//配置CORS中间件，后序的所有接口都会被处理成CORS接口</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br><span class="line"><span class="comment">//开启了CORS的接口,所以CORS要写在路由前面。为什么可以叫做接口呢，实际上就是相当于前端调用的</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/get&#x27;</span>, <span class="function">(<span class="params">res</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>实现接口JSONP步骤</p>
<ol>
<li>获取客户端发送的回调函数的名字</li>
<li>得到要通过JSONP形式发送给客户端的数据</li>
<li>根据前两步得到的数据，拼接处一个函数调用的字符串</li>
<li>将上一步拼接得到的字符串，响应给客户端的<script>标签进行解析执行</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;api/jsonp&#x27;</span>, <span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//1.获取客户都拿发送过来的回调函数的名字</span></span><br><span class="line">    <span class="keyword">const</span> funcName = req.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line">    <span class="comment">//2.定义要发送到客户端的数据对象</span></span><br><span class="line">    <span class="keyword">const</span> data= &#123;<span class="attr">name</span>:<span class="string">&#x27;ax&#x27;</span>, <span class="attr">age</span>:<span class="number">23</span>&#125;</span><br><span class="line">    <span class="comment">//3. 拼接出一个函数的调用</span></span><br><span class="line">    <span class="keyword">const</span> scriptstr=<span class="string">`<span class="subst">$&#123;funcName&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringfy(data)&#125;</span>)`</span></span><br><span class="line">    <span class="comment">//4. 拼接的字符串响应给客户端</span></span><br><span class="line">    res.<span class="title function_">send</span>(scriptstr);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用jquery发送JSONP请求</p>
<p>调用$.ajax()函数，提供JSONP的配置选项，从而发起JSONP请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#btnJSONP&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">      <span class="attr">type</span>:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">      <span class="attr">url</span>:<span class="string">&#x27;http://127.0.0.1/api/jsonp&#x27;</span>,</span><br><span class="line">      <span class="attr">dataType</span>:<span class="string">&#x27;jsonp&#x27;</span>,</span><br><span class="line">      <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">//函数名呢，jQuery发送了？</span></span><br></pre></td></tr></table></figure>

<h2 id="8-mysql模块"><a href="#8-mysql模块" class="headerlink" title="8. mysql模块"></a>8. mysql模块</h2><ol>
<li>安装mysql第三方模块</li>
<li>通过mysql模块连接到MySQL数据库（建立与MySQL数据库连接</li>
<li>通过MySQL模块执行MySQL语句</li>
</ol>
<h3 id="配置Mysql模块"><a href="#配置Mysql模块" class="headerlink" title="配置Mysql模块"></a>配置Mysql模块</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入MySQL模块</span></span><br><span class="line"><span class="keyword">const</span> mysql= <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>);</span><br><span class="line"><span class="comment">//2.建立与MySQL数据库的连接</span></span><br><span class="line"><span class="comment">//提供一个对象</span></span><br><span class="line"><span class="keyword">const</span> db = mysql.<span class="title function_">createPool</span>(&#123;</span><br><span class="line">    <span class="attr">host</span>:<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment">//数据库IP地址</span></span><br><span class="line">    <span class="attr">user</span>:<span class="string">&#x27;root&#x27;</span>,  <span class="comment">//登录数据库的账号</span></span><br><span class="line">    <span class="attr">password</span>:<span class="string">&#x27;admin123&#x27;</span>,  <span class="comment">//登录数据库的密码</span></span><br><span class="line">    <span class="attr">database</span>:<span class="string">&#x27;db_01&#x27;</span>  <span class="comment">//指定操作的数据库</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><p>db.**query()**指定要执行的SQL语句，通过回调拿到执行的结果。</p>
<p><strong>查询数据</strong></p>
<p>返回结果为对象数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询users 表中的所有数据</span></span><br><span class="line"><span class="comment">//select语句执行结果是对象数组</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;select * from users&#x27;</span>;</span><br><span class="line">db.<span class="title function_">query</span>(sqlStr, <span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//查询数据失败</span></span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">    <span class="comment">//查询数据成功</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>插入数据</strong></p>
<p>以数组的形式插入数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向users表中插入数据，username为spider-man，password为pcc123</span></span><br><span class="line"><span class="comment">//占位符？  ；  results返回对象判断是否插入成功</span></span><br><span class="line"><span class="comment">//1.定义插入到表中的数据对象</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">username</span>:<span class="string">&#x27;spider-man&#x27;</span>, password = <span class="string">&#x27;pcc123&#x27;</span>&#125;</span><br><span class="line"><span class="comment">//2.待执sql语句，其中英文的？表示占位符</span></span><br><span class="line"><span class="keyword">const</span> sqlstr = <span class="string">&#x27;INSERT INTO users (username,password) VALUES (?,?)&#x27;</span></span><br><span class="line"><span class="comment">//3.使用数组的形式，以此为？占位符指定具体的值</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr, [user.<span class="property">username</span>, user.<span class="property">password</span>], <span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="comment">//执行结果为对象，其中的affectedRows可以判断</span></span><br><span class="line">    <span class="keyword">if</span>(results.<span class="property">affectedRows</span>===<span class="number">1</span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;插入成功&#x27;</span>)&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>便捷方式：如果数据对象的每个属性和数据表的字段<strong>一一对应</strong>，则可以通过快捷方式插入数据。</p>
<p>SQL语句有多个占位符时，需要数组为每个占位符指定具体的值；如果只有一个占位符则可以省略数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">username</span>:<span class="string">&#x27;spider&#x27;</span>, <span class="attr">password</span>:<span class="string">&#x27;hhh&#x27;</span>&#125;</span><br><span class="line"><span class="comment">//待执行SQL语句，英文的？表示占位符</span></span><br><span class="line"><span class="keyword">const</span> sqlStr= <span class="string">&#x27;INSERT INTO users SET ?&#x27;</span></span><br><span class="line"><span class="comment">//3.直接将数据对象当作占位符的值</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr, user, <span class="function">(<span class="params">err, result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="comment">//执行结果为对象，其中的affectedRows可以判断</span></span><br><span class="line">    <span class="keyword">if</span>(results.<span class="property">affectedRows</span>==<span class="number">1</span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;插入成功&#x27;</span>)&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>更新数据</strong></p>
<p>同样使用数组形式对数据更新。执行结果也是对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">id</span>:<span class="number">6</span>, <span class="attr">username</span>:<span class="string">&#x27;aaa&#x27;</span>, <span class="attr">password</span>:<span class="string">&#x27;000&#x27;</span>&#125;</span><br><span class="line"><span class="comment">//定义SQL语句</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;update users set username=?, password=? where id=?&#x27;</span>;</span><br><span class="line"><span class="comment">//执行SQL语句</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr, [user.<span class="property">userame</span>, user.<span class="property">password</span>, user.<span class="property">id</span>], <span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="comment">//执行结果为对象，其中的affectedRows可以判断</span></span><br><span class="line">    <span class="keyword">if</span>(results.<span class="property">affectedRows</span>==<span class="number">1</span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新成功&#x27;</span>)&#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>便捷方式：和插入一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">id</span>:<span class="number">6</span>, <span class="attr">username</span>:<span class="string">&#x27;aaa&#x27;</span>, <span class="attr">password</span>:<span class="string">&#x27;000&#x27;</span>&#125;</span><br><span class="line"><span class="comment">//定义SQL语句</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;update users set ? where id=?&#x27;</span>;</span><br><span class="line"><span class="comment">//执行SQL语句</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr, [user, user.<span class="property">id</span>], <span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="comment">//执行结果为对象，其中的affectedRows可以判断</span></span><br><span class="line">    <span class="keyword">if</span>(results.<span class="property">affectedRows</span>==<span class="number">1</span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新成功&#x27;</span>)&#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>删除数据</strong></p>
<p>推荐使用id这样的唯一标识删除对应数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  sqlStr = <span class="string">&#x27;DELETE FROM users WHERE id=?&#x27;</span></span><br><span class="line"><span class="comment">//调用db.query()执行SQL语句时，为占位符指定具体的值</span></span><br><span class="line"><span class="comment">//如果sql语句只有一个占位符，则可以省略数组</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr, <span class="number">7</span>, <span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="comment">//执行结果为对象，其中的affectedRows可以判断</span></span><br><span class="line">    <span class="keyword">if</span>(results.<span class="property">affectedRows</span>==<span class="number">1</span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>)&#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>标记删除：伪删除动作。在表中设置类似于status这样的状态字段，来标记当前这条数据是否被删除，当用户执行了删除的动作时，并没有真正删除，而是将status用update语句更新，假装删除了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;update users set status =? where id=?&#x27;</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr, [<span class="number">1</span>,<span class="number">6</span>], <span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="comment">//执行结果为对象，其中的affectedRows可以判断</span></span><br><span class="line">    <span class="keyword">if</span>(results.<span class="property">affectedRows</span>==<span class="number">1</span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;标记删除成功&#x27;</span>)&#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="9-前后端的身份认证"><a href="#9-前后端的身份认证" class="headerlink" title="9. 前后端的身份认证"></a>9. 前后端的身份认证</h2><h3 id="1-Web开发模式"><a href="#1-Web开发模式" class="headerlink" title="1. Web开发模式"></a>1. Web开发模式</h3><ol>
<li>基于服务端渲染的Web开发模式</li>
</ol>
<p>服务器端渲染：服务器发送给客户端的HTML页面，是在服务端通过字符串拼接动态生成的。客户端不需要Ajax这样的技术额外请求页面的数据，因为这样的页面自带数据，动态生成的。</p>
<p>优点：前端耗时少，因为服务器端已经动态生成好了HTML页面，前端直接渲染页面就好啊。尤其便宜移动端</p>
<p>​            有利于SEO，因为响应的是玩则会那个的HMTL页面内容，爬虫更容易获取信息，更有利于SEO</p>
<p>缺点：占用服务器端资源，如果请求太多，会对服务器造成访问压力；不利于前后端分离，前端复杂度高的项目开发效率低</p>
<ol start="2">
<li>前后端分离的web开发模式</li>
</ol>
<p>依赖于Ajax技术的广泛应用。</p>
<p>优点：前端专注于UI页面的开发，后端专注于API的开发；用户体验好，Ajax轻松实现页面的局部刷新；减轻服务器端的渲染压力</p>
<p>缺点：不利于SEO，但是可以利用Vue、react等前端框架的SSR技术可以很好的解决</p>
<p>根据不同用户场景</p>
<p>企业级网站，展示而不是复杂的交互且需要良好SEO服务器端；后台管理项目前后端分离</p>
<h3 id="2-身份认证"><a href="#2-身份认证" class="headerlink" title="2. 身份认证"></a>2. 身份认证</h3><p>Authentication：web开发中涉及到用户身份的认证：如手机验证码登录，邮箱密码登录</p>
<p>服务器端：推荐使用session认证机制</p>
<p>前后端分离：推荐使用jwt认证机制</p>
<h3 id="3-session认证机制"><a href="#3-session认证机制" class="headerlink" title="3. session认证机制"></a>3. session认证机制</h3><p><strong>HTTP协议的无状态性</strong></p>
<p>指客户端每次HTTP请求都是<strong>独立</strong>的，连续多个请求之间没有直接的关系，<strong>服务器不会主动保留每次HTTP请求的状态</strong>。超市收银员记不住谁是vip</p>
<p><strong>突破HTTP无状态的限制</strong></p>
<p>使用cookie身份认证的标识让服务器识别http请求。使用vip卡来标识vip客户的身份</p>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a><strong>cookie</strong></h4><ol>
<li><p>存储在<strong>用户浏览器</strong>中的一段不超过4kb的<strong>字符串</strong>，由一个名称和一个值和其他几个用于控制cookie有效期、安全性、适用范围的可选属性组成。</p>
<p>不同域名下的cookie各自独立，不能互相访问，每当客户端发起请求时，会自动将当前域名下所有<strong>未过期的Cookie</strong>一同发送到服务器。百度的域名和微博域名的Cookie相互独立，不能互相访问，百度每次发送一个请求，会把其下<strong>所有</strong>未过期的Cookie一同发送到服务器</p>
</li>
<li><p>特性：</p>
<ol>
<li>自动发送（不需要程序员操心发送</li>
<li>域名独立</li>
<li>过期时限：每个Cookie都有有效期，不过期的才能发送给服务器，可以设置过期时限</li>
<li>4KB限制</li>
</ol>
</li>
<li><p>Cookie在身份认证中的作用：客户端第一次请求服务器时，服务器通过<strong>响应头</strong>的形式，向客户端发送一个身份认证的Cookie，客户端自动将Cookie保存在浏览器中。当后面客户端浏览器再请求服务器时，浏览器会自动将Cookie以<strong>请求头</strong>的形式发送给服务器，服务器即可验明客户端身份，响应当前用户的内容。</p>
<p>​    使用浏览器工具中的network可以查看发送请求时的请求头和响应头，application中可以查看cookie</p>
</li>
<li><p>Cookie不具有安全性。因为Cookie存储在浏览器中，而且浏览器也提供了读写Cookie的Api，因此Cookie很容易被伪造。因此不建议服务器将重要的隐私数据通过Cookie形式发送给浏览器。比如客户会伪造会员卡</p>
</li>
<li><p>提高身份认证的安全性：会员卡（客户端保存）+刷卡认证（服务器端认证）</p>
</li>
<li><p>Session的工作原理。图崩了</p>
</li>
</ol>
<p><img src="C:\Users\cn\AppData\Roaming\Tencent\Users\1902755928\QQ\WinTemp\RichOle\7YOI">U~87B9T[FNBWT({724.png)</p>
<h4 id="Express中使用Session认证"><a href="#Express中使用Session认证" class="headerlink" title="Express中使用Session认证"></a>Express中使用Session认证</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装</span></span><br><span class="line">npm i express-session</span><br><span class="line"><span class="comment">//导入session中间件</span></span><br><span class="line"><span class="keyword">var</span> session =  <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>);</span><br><span class="line"><span class="comment">//配置中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">secret</span>:<span class="string">&#x27;woshithea&#x27;</span>, <span class="comment">//secret属性的值可以为任意字符串</span></span><br><span class="line">    <span class="attr">resave</span>:<span class="literal">false</span>,   <span class="comment">//固定写法</span></span><br><span class="line">    <span class="attr">saveUninitialized</span>:<span class="literal">true</span>;  <span class="comment">//固定写法</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p><strong>向session中存数据</strong></p>
<p>express-session中间件配置成功后，即可通过<strong>req.session</strong>访问和使用session对象，从而存储用户的关键信息。只有成功配置了express-session中间件之后，才能够通过req点出session属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将登录成功后的用户信息保存到session中（场景）</span></span><br><span class="line"><span class="comment">//登录api接口</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>, <span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//判断用户提交的登录信息是否正确</span></span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">body</span>.<span class="property">username</span> !==<span class="string">&#x27;admin&#x27;</span>||req.<span class="property">body</span>.<span class="property">password</span> !=<span class="string">&#x27;000000&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>:<span class="number">1</span>, <span class="attr">msg</span>:<span class="string">&#x27;登录失败&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用户登录成功，配置session存储关键信息</span></span><br><span class="line">    <span class="comment">//只有成功配置了express-session中间件之后，才能够通过req点出session属性</span></span><br><span class="line">    req.<span class="property">session</span>.<span class="property">user</span> = req.<span class="property">body</span>; <span class="comment">//用户信息</span></span><br><span class="line">    req.<span class="property">session</span>.<span class="property">islogin</span> = <span class="literal">true</span>;<span class="comment">//用户登录状态</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>:<span class="number">0</span>, <span class="attr">msg</span>:<span class="string">&#x27;登录成功&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>从session中取数据</strong></p>
<p>可以直接从req.session对象获取之前存储的数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取用户姓名的接口</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/username&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//判断用户是否登录</span></span><br><span class="line">    <span class="keyword">if</span>(!req.<span class="property">session</span>.<span class="property">islogin</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>:<span class="number">1</span>, <span class="attr">msg</span>:<span class="string">&#x27;fail&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">        <span class="attr">username</span>:req.<span class="property">session</span>.<span class="property">user</span>.<span class="property">username</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>清空session数据</strong></p>
<p>调用**req.session.destroy()**清空服务器保存的session信息，只会清空当前用户的session信息，不会清空其它用户对应的session</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//退出登录的接口</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/logout&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    req.<span class="property">session</span>.<span class="title function_">destroy</span>();</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&#x27;退出登录成功&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>将HTML网页作为静态资源托管，访问时可避免出现跨域问题，因此可以记住Cookie，Ohhhhhh，难怪最开始用跨域访问测试网页get请求不成功，因为Cookie默认不支持跨域访问！</p>
<h3 id="JWT认证机制"><a href="#JWT认证机制" class="headerlink" title="JWT认证机制"></a>JWT认证机制</h3><p>session认证机制需要配合Cookie才能实现。<strong>Cookie默认不支持跨域访问</strong>，所以，当涉及到前端跨域请求后端接口的时候，需要额外配置，才能实现session认证。</p>
<p>跨域请求推荐使用JWT认证机制</p>
<h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a><strong>JWT</strong></h4><p>JSON Web Token：当前最流行的跨域认证方案。</p>
<p><strong>工作原理</strong></p>
<p>用户的信息通过加密后的Token字符串的形式发送给客户端，保存在客户端浏览器（<strong>localStorage或SessionStorage</strong>）中。客户端再次发送请求时，通过请求头的<strong>Authorization</strong>字段，将Token发送给服务器，服务端通过还原Token字符串来认证那个用户的身份。服务端不保存Token。</p>
<p>Session是保存在服务器端</p>
<p><strong>组成部分</strong></p>
<p>JWT通常由<strong>Header</strong>（头部）、<strong>Payload（有效荷载）</strong>、<strong>Signature（签名）</strong>三部分组成，使用’.’分割。</p>
<p>Payload：用户信息经过加密后生成的字符串</p>
<p>Header和Signature：和安全性相关的部分，只是为了保证Token安全</p>
<p><strong>使用方式</strong></p>
<p>客户端接收到服务器返回的JWT后，通常存储在localStorage或sessionStorage中。推荐与服务器通信时将JWT放在HTTP请求头中的Authorization字段中。</p>
<p>Authorization：Bearer <token></p>
<h4 id="Express中使用JWT"><a href="#Express中使用JWT" class="headerlink" title="Express中使用JWT"></a>Express中使用JWT</h4><p>npm install jsonwebtoken express-jwt 安装这两个包</p>
<p>jsonwebtoken用于生成JWT字符串，express-token用户将JWT字符串解析还原成JSON对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入包</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> expressJWT  = <span class="built_in">require</span>(<span class="string">&#x27;express-jwt&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>定义secret密钥</strong></p>
<p>保证JWT字符串的安全性,定义用于加密和解密的secret密钥,防止JWT在传输过程中被破解。</p>
<p>secret密钥本质是一个字符串，越复杂越好</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> secretKey= <span class="string">&#x27;ehrfwehriw&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>生成JWT</strong></p>
<p>调用jsonwebtoken包提供的**sign()**方法，将用户信息加密生成JWT字符串</p>
<p>参数一：用户信息对象，参数二：加密密钥，参数三：配置对象，设置如过期时限等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//登录接口</span></span><br><span class="line">web.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>, <span class="keyword">function</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">    <span class="comment">//...省略登录失败的代码</span></span><br><span class="line">    <span class="keyword">const</span> userinfo = req.<span class="property">body</span></span><br><span class="line">    <span class="keyword">if</span>(userinfo.<span class="property">username</span> !==<span class="string">&#x27;admin&#x27;</span>||userinfo.<span class="property">password</span> !=<span class="string">&#x27;000000&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>:<span class="number">400</span>, <span class="attr">msg</span>:<span class="string">&#x27;登录失败&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//登录成功，生成JWT字符串，通过token属性响应给客户端</span></span><br><span class="line">   res.<span class="title function_">send</span>(&#123;</span><br><span class="line">       <span class="attr">status</span>:<span class="number">200</span>,</span><br><span class="line">       <span class="attr">message</span>:<span class="string">&#x27;登陆成功&#x27;</span>,</span><br><span class="line">       <span class="attr">token</span>:jwt.<span class="title function_">sign</span>(&#123;<span class="attr">username</span>:userinfo.<span class="property">username</span>&#125;, secretKey, &#123;<span class="attr">expiresIn</span>:<span class="string">&#x27;30s&#x27;</span>&#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>还原Token</strong></p>
<p>配置express-jwt。注册express-jwt中间件，使用express JWT({secret:secretKey})解析token。</p>
<p>踩坑：注意，express-jwt版本问题，新版本已经不支持当作函数使用了，如果要用下面的代码，要把express-jwt版本改为6.1.1重新安装。同时，6.1.1的版本必须配置爱algorithms参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.use注册中间件</span></span><br><span class="line"><span class="comment">//expressJWT(&#123;secret:secretKey&#125;)是解析token的中间件，secret是配置对象</span></span><br><span class="line"><span class="comment">//.unless(&#123;path:[/^\/api\//] &#125;)指定哪些接口不需要访问权限。这里定义以&#x27;/api&#x27;开头的接口不需要权限</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">expressJWT</span>(&#123;<span class="attr">secret</span>:secretKey&#125;).<span class="title function_">unless</span>(&#123;<span class="attr">path</span>:[<span class="regexp">/^\/api\//</span>] &#125;))</span><br></pre></td></tr></table></figure>

<p><strong>req.user</strong></p>
<p>express-jwt配置成功后，就可以把解析出来的用户信息挂载到req.user属性上，因此可以通过req.user属性获取用户信息。获取的用户信息是当时生成token时进行配置的jwt.sign()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/admin/info&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>)&#123;</span><br><span class="line">    <span class="comment">//通过req.user将用户信息发送给客户端</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>:<span class="number">200</span>,</span><br><span class="line">        <span class="attr">message</span>:<span class="string">&#x27;成功&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>:req.<span class="property">user</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>浏览器在发送请求时，还需要设置header的authorization字段，携带token，但是不知道怎么做</p>
<p><strong>捕获jwt失败产生的错误</strong></p>
<p>使用express-jwt解析token字符串时，如果客户端发送过来的token字符串<strong>过期或不合法</strong>，会产生一个解析失败的错误，影响项目正常运行。可以通过Express的<strong>错误中间件</strong>，捕获这个错误并进行相关处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//token解析失败导致的错误</span></span><br><span class="line">    <span class="keyword">if</span>(err.<span class="property">name</span>  ===<span class="string">&#x27;UnauthorizedError&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>:<span class="number">401</span>, <span class="attr">message</span>:<span class="string">&#x27;无效token&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其它原因导致的错误</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>:<span class="number">500</span>,<span class="attr">message</span>:<span class="string">&#x27;未知错误&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/26/Node-js/" data-id="cl3n2rvot00019owa8ez1g115" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-test-my-site" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/26/test-my-site/" class="article-date">
  <time datetime="2022-05-26T12:56:31.000Z" itemprop="datePublished">2022-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/26/test-my-site/">test_my_site</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/26/test-my-site/" data-id="cl3n2nhr50000uswa3rep0n6y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TypeScript" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/26/TypeScript/" class="article-date">
  <time datetime="2022-05-26T12:56:31.000Z" itemprop="datePublished">2022-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/26/TypeScript/">TypeScript</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TS无法在浏览器直接执行，需要编译成js才能执行。</p>
<p>TS的编译器tsc依赖于Node.js环境。</p>
<p><strong>开发环境搭建</strong></p>
<ol>
<li>下载node.js</li>
<li>安装Node.js</li>
<li>使用npm全局安装typescript：npm i -g typescript</li>
</ol>
<p>添加开发时依赖<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/awesome-typescript-loader">awesome-typescript-loader</a>和<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/source-map-loader">source-map-loader</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev typescript awesome-typescript-loader source-map-loader</span><br></pre></td></tr></table></figure>

<p>这些依赖会让TypeScript和webpack在一起良好地工作。 awesome-typescript-loader可以让Webpack使用TypeScript的标准配置文件<code>tsconfig.json</code>编译TypeScript代码。 source-map-loader使用TypeScript输出的sourcemap文件来告诉webpack何时生成<em>自己的</em>sourcemaps。 这就允许你在调试最终生成的文件时就好像在调试TypeScript源码一样。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p><strong>字面量</strong></p>
<p>限制变量的值就是该字面量的值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a : <span class="string">&quot;male&quot;</span>|<span class="string">&quot;female&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>any任意类型</strong></p>
<p>一个变量设置为any类型相当于对该变量关闭了TS的类型检测。使用TS时不建议使用any类型（实际开发中都会用any。。。）。</p>
<p>声明变量如果不指定类型，则TS解析器会自动判断变量的类型为any（隐式any）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">d</span>:<span class="built_in">any</span>;</span><br><span class="line">d =<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐式any</span></span><br><span class="line"><span class="keyword">let</span> d;</span><br><span class="line">d =<span class="number">10</span>;</span><br><span class="line">d=<span class="string">&#x27;hi&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>unknown</strong></p>
<p>unknown是类型安全的any，unknown类型的变量不能直接赋给其它变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//e为unknown</span></span><br><span class="line">str =e;<span class="comment">//err</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> e===<span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line">	str =e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>void</strong></p>
<p>常用于函数返回值为空值。</p>
<p><strong>never</strong></p>
<p>表示永远不会返回结果。比如抛出异常的函数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>):<span class="built_in">never</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>object</strong></p>
<p>对象，一切都对象，这样的object并不是专指包含很多属性的对象。指定包含属性的对象应该使用{}。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a :<span class="built_in">object</span>;</span><br><span class="line">a = &#123;&#125;;</span><br><span class="line">a = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&#125;用来指定包含哪些属性</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:&#123;<span class="attr">name</span>:<span class="built_in">string</span>&#125;;</span><br><span class="line">b=&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组类型</strong></p>
<p>语法:</p>
<p>​    类型[]</p>
<p>​    Array&lt;类型&gt;</p>
<p><strong>元组</strong></p>
<p>元组就是固定长度的数组。类型和长度必须和指定的一致。</p>
<p><strong>枚举</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span>&#123;</span><br><span class="line">    <span class="title class_">Male</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="title class_">Female</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Gender</span>.<span class="property">female</span>;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p><strong>类型别名</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myType= <span class="number">1</span> |<span class="number">2</span> |<span class="number">3</span> | <span class="number">4</span> |<span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">k</span>:myType;</span><br><span class="line"><span class="keyword">let</span> m :myType</span><br><span class="line">k =<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> htype = mystring;</span><br></pre></td></tr></table></figure>

<p><strong>可选属性</strong></p>
<p>在属性后面加上?表示一个可选的属性。</p>
<p>对象字面量会做额外属性检查，不能有指定属性之外的属性。而直接传入对象可以避免这样的检查。或者使用任意属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b :&#123;<span class="attr">name</span>:<span class="built_in">string</span>, age?:<span class="built_in">number</span>&#125;</span><br><span class="line">b = &#123;<span class="attr">name</span>:<span class="string">&#x27;xiaoming&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象字面量</span></span><br><span class="line">b = &#123;<span class="attr">name</span>:<span class="string">&#x27;wfe&#x27;</span>,<span class="attr">sex</span>:<span class="string">&#x27;fe&#x27;</span>&#125;；<span class="comment">//err，没有sex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定任意类型的属性</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: &#123;<span class="attr">name</span>:<span class="built_in">string</span>, [<span class="attr">propName</span>:<span class="built_in">string</span>]:<span class="built_in">any</span>&#125;</span><br><span class="line">c =&#123;<span class="attr">name</span>:<span class="string">&#x27;xiaoming&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>, <span class="attr">gender</span>:<span class="string">&#x27;female&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>联合类型</strong></p>
<p>ts中可以使用|来连接多个类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c :<span class="built_in">boolean</span> |<span class="built_in">string</span>;</span><br><span class="line">c = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数结构的类型声明</strong></p>
<p>语法：</p>
<p>(形参：类型，形参：类型,…)=&gt;返回值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">d</span>:<span class="function">(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>)=&gt;</span><span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p><strong>类型断言</strong></p>
<p>编译器不知道变量类型，但我们自己确定知道变量的类型，就可以将做类型断言，告诉解析器变量的实际类型。</p>
<p>语法：</p>
<ol>
<li>变量as 类型</li>
<li>&lt;类型&gt;变量</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = e <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">str = &lt;<span class="built_in">string</span>&gt;e;</span><br></pre></td></tr></table></figure>



<h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前<em>获取</em>它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// okay to capture &#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能在&#x27;a&#x27;被声明前调用&#x27;foo&#x27;</span></span><br><span class="line"><span class="comment">// 运行时应该抛出错误</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a;</span><br></pre></td></tr></table></figure>



<p><strong>解构</strong></p>
<ol>
<li>就像数组解构，你可以用没有声明的赋值：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123; a, b &#125; = &#123; a: &quot;baz&quot;, b: 101 &#125;);</span><br></pre></td></tr></table></figure>

<p>注意，我们需要用括号将它括起来，因为Javascript通常会将以 <code>&#123;</code> 起始的语句解析为一个块。</p>
<ol start="2">
<li>如果你想指定它的类型， 仍然需要在其后写上完整的模式。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;a, b&#125;: &#123;a: string, b: number&#125; = o;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>指定默认值</li>
</ol>
<p>解构也能用于函数声明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b &#125; = &#123; a: <span class="string">&quot;&quot;</span>, b: <span class="number">0</span> &#125;</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// ok, default to &#123; a: &quot;&quot;, b: 0 &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b = <span class="number">0</span> &#125; = &#123; a: <span class="string">&quot;&quot;</span> &#125;</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(&#123; <span class="attr">a</span>: <span class="string">&quot;yes&quot;</span> &#125;); <span class="comment">// ok, default b = 0</span></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// ok, default to &#123;a: &quot;&quot;&#125;, which then defaults b = 0</span></span><br><span class="line"><span class="title function_">f</span>(&#123;&#125;); <span class="comment">// error, &#x27;a&#x27; is required if you supply an argument</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>展开</li>
</ol>
<p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">自身的可枚举属性</a>。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  p = <span class="number">12</span>;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"><span class="keyword">let</span> clone = &#123; ...c &#125;;</span><br><span class="line">clone.<span class="property">p</span>; <span class="comment">// ok</span></span><br><span class="line">clone.<span class="title function_">m</span>(); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p><strong>tsconfig.json</strong></p>
<p>tsconfig.json是ts编译的配置文件，ts编译器根据它所包含的信息对代码进行编译。</p>
<p>include：用于指定需要编译的ts文件。</p>
<p>exclude：不需要被编译的文件目录，默认值为node_modules,bower_components,jspm_packages等。</p>
<p>files：指定被编译文件的列表，只有需要编译的文件少时才会用到。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;include&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;./src/**/*&quot;</span><span class="punctuation">,</span> <span class="comment">//src目录下的任意目录任意文件都会被编译</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;exclue&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span><span class="punctuation">,</span><span class="string">&quot;bower_components&quot;</span><span class="punctuation">,</span><span class="string">&quot;jspm_packages&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>compilerOptions</strong></p>
<p>编译器选项：是配置文件中非常重要也比较复杂的配置选项。</p>
<p>子选项：</p>
<ul>
<li>目标：target指定ts被编译为的ES版本</li>
<li>模块：module指定要使用的模块化的规范。比如import</li>
<li>库：lib指定项目中要使用的库。如果不指定就不能使用那些库，通常不需要改。</li>
<li>outDir：指定编译后文件所在的目录</li>
<li>outFile：将所有全局作用域中的代码合并为一个文件，并指定所存文件位置。要合并module，必须指定module为amd或system。</li>
<li>allowJs：是否对js文件进行编译，默认为false; checkJs：是否检查js代码是否符合规范。</li>
<li>removeComments：是否移除注释</li>
<li>noEmit：不生成编译后的文件</li>
<li>noEmitOnError：当有错误不生成编译后的文件</li>
<li>alwaysStrict：用来设置编译后的js文件是否开启严格模式，默认为false。开启后会在js文件中加上’use strict’，如果有模块module代码会自动打开严格模式，alwaysstrict开启后js文件中也不会有’use strict’</li>
<li>noImplicitAny：是否允许隐式的any开启。没有指明类型的都会被认为any</li>
<li>noImplicitThis：是否允许使用不明确类型的this</li>
<li>strictNullChecks：是否严格的检查空值</li>
<li>strict：所有严格检查的总开关，负责总控以上所有严格检查的总开关</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span><span class="string">&quot;ES3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span><span class="string">&quot;abc&quot;</span><span class="punctuation">,</span> <span class="comment">//none,commonjs,amd,system,es2015</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span><span class="string">&quot;./dist&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span><span class="string">&quot;./dist/app.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span><span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;checkJs&quot;</span><span class="punctuation">:</span><span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alwaysStrict&quot;</span><span class="punctuation">:</span><span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;noImplicityAny&quot;</span><span class="punctuation">:</span><span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;noImplicitThis&quot;</span><span class="punctuation">:</span><span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span><span class="punctuation">:</span><span class="keyword">true</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strictNUllChecks</span></span><br><span class="line"><span class="keyword">let</span> box = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">box?.<span class="title function_">addEventListener</span>(...)</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">if</span>(box)&#123;</span><br><span class="line">	box.<span class="title function_">addEventListener</span>(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="webpack打包ts代码"><a href="#webpack打包ts代码" class="headerlink" title="webpack打包ts代码"></a>webpack打包ts代码</h2><ol>
<li>初始化项目生成package.json文件：npm init -y</li>
<li>下载webpack，webpack-cli, typescript, ts-loader</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack webpack-cli typescript ts-loader</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编写webpack.config.js文件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//webpack中的所有配置信息都应该卸载module.exports中</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="comment">//指定入口文件</span></span><br><span class="line">    <span class="attr">entry</span>:<span class="string">&#x27;./src/index.ts&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定打包文件的目录</span></span><br><span class="line">    <span class="attr">output</span>:&#123;</span><br><span class="line">        <span class="comment">//指定打包文件的目录</span></span><br><span class="line">        <span class="attr">path</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;dist&#x27;</span>);</span><br><span class="line">        <span class="comment">//打包后文件的名称</span></span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&#x27;boudle.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定webpack打包时要使用的模块</span></span><br><span class="line">    <span class="attr">module</span>:&#123;</span><br><span class="line">        <span class="comment">//指定要加载的规则</span></span><br><span class="line">        <span class="attr">rule</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//test指定规则生效的文件</span></span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.ts$/</span>,</span><br><span class="line">                <span class="comment">//要使用的loader</span></span><br><span class="line">                <span class="attr">use</span>: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">                <span class="comment">//要排除的文件</span></span><br><span class="line">                <span class="attr">exclude</span>:<span class="regexp">/node-modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编写tsconfig.json文件</li>
<li>在package.json文件中加一个build命令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;:&#123;</span><br><span class="line">	&quot;build&quot;:webpack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>webpack.config.js文件中使用html-webpack-plugin插件可以帮助自动生成html文件</li>
</ol>
<p>可以为html指定基本结构template。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm i -D html-webpack-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入插件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HTMLWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置webpack插件</span></span><br><span class="line"><span class="attr">plugins</span>:[</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HTMLWebpackPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">template</span>:<span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>设置package.json中的start可以直接打开chrome网页，并且可以对文件进行监视，当文件change时会自动对项目重新编译。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span>    </span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span><span class="string">&quot;webpack&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span><span class="string">&quot;webpack serve --open chrome.exe&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>clean插件：每次重新编译时会将dist目录清空，然后生成重新编译的文件，防止冗余。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">npm i -D clean-webpack-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入插件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CleanWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置webpack插件</span></span><br><span class="line"><span class="attr">plugins</span>:[</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HTMLWebpackPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">template</span>:<span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>resolve设置引用模块，指定哪些文件可以作为模块使用。依然在webpack.config.js文件</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve<span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">	extensions<span class="punctuation">:</span><span class="punctuation">[</span>&#x27;.ts&#x27;<span class="punctuation">,</span>&#x27;.js&#x27;<span class="punctuation">]</span> <span class="comment">//以ts，js扩展名结尾的都能作为模块</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Babel</strong></p>
<p>安装babel依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm i -D @babel/core @babel/preset-env babel-loader core-js</span><br><span class="line">//babel/core是核心工具；preset-env预先设置环境，因为可能兼容ie，Firefox等不同浏览器，preset预置了不同环境。</span><br></pre></td></tr></table></figure>

<p>webpack.config.js添加babel加载器</p>
<p>加载器的顺序是从后往前执行。babel加载器中还需要写其它配置信息，需要使用{}</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">module<span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">//指定要加载的规则</span></span><br><span class="line">        rule<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="comment">//test指定规则生效的文件</span></span><br><span class="line">                test<span class="punctuation">:</span>/\.ts$/<span class="punctuation">,</span></span><br><span class="line">                <span class="comment">//要使用的loader</span></span><br><span class="line">                use<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="comment">//配置babel</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="comment">//指定加载器</span></span><br><span class="line">                        loader<span class="punctuation">:</span><span class="string">&quot;babel-loader&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="comment">//设置babel</span></span><br><span class="line">                        options<span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="comment">//设置预定义的环境</span></span><br><span class="line">                            presets<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">                                <span class="punctuation">[</span></span><br><span class="line">                                    <span class="comment">//指定环境的插件</span></span><br><span class="line">                                    <span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="comment">//配置信息</span></span><br><span class="line">                                    <span class="punctuation">&#123;</span></span><br><span class="line">                                        <span class="comment">//需要兼容的目标浏览器</span></span><br><span class="line">                                        target<span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                                            <span class="attr">&quot;chrome&quot;</span><span class="punctuation">:</span><span class="string">&quot;88&quot;</span></span><br><span class="line">                                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                                        </span><br><span class="line">                                        <span class="comment">//指定corejs的版本,可以为ie这样的浏览器引入</span></span><br><span class="line">                                        <span class="attr">&quot;corejs&quot;</span><span class="punctuation">:</span><span class="string">&quot;3&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                        <span class="comment">//使用corejs的方式”usage“表示按需加载</span></span><br><span class="line">                                        <span class="attr">&quot;useBuiltIns&quot;</span><span class="punctuation">:</span><span class="string">&quot;usage&quot;</span></span><br><span class="line">									<span class="punctuation">&#125;</span></span><br><span class="line">                                <span class="punctuation">]</span></span><br><span class="line">                            <span class="punctuation">]</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                    &#x27;ts-loader&#x27;<span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">                <span class="comment">//要排除的文件</span></span><br><span class="line">                exclude<span class="punctuation">:</span>/node-modules/</span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ol>
<li>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用<code>readonly</code>来指定只读属性:</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>TypeScript具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改，把整个<code>ReadonlyArray</code>赋值到一个普通数组也是不可以的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">ro</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.<span class="title function_">push</span>(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.<span class="property">length</span> = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>但是可以用类型断言重写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro as number[];</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过<em><strong>额外属性检查</strong></em>，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSquare</span>(<span class="params">config: SquareConfig</span>): &#123; <span class="attr">color</span>: <span class="built_in">string</span>; <span class="attr">area</span>: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;);<span class="comment">// error: &#x27;colour&#x27; not expected in type &#x27;SquareConfig&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用类型断言绕开这些检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mySquare = createSquare(&#123; width: 100, opacity: 0.5 &#125; as SquareConfig);</span><br></pre></td></tr></table></figure>

<p>将这个对象赋值给一个另一个变量跳过这些检查的方式： 因为<code>squareOptions</code>不会经过额外属性检查，没有对象字面量，所以编译器不会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let squareOptions = &#123; colour: &quot;red&quot;, width: 100 &#125;;</span><br><span class="line">let mySquare = createSquare(squareOptions);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span>;</span><br><span class="line">mySearch = <span class="keyword">function</span>(<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.<span class="title function_">search</span>(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会<strong>推断</strong>出参数类型，因为函数直接赋值给了<code>SearchFunc</code>类型变量。 函数的返回值类型就是通过其返回值推断出来的（此例是<code>false</code>和<code>true</code>）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span>;</span><br><span class="line">mySearch = <span class="keyword">function</span>(<span class="params">src, sub</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = src.<span class="title function_">search</span>(sub);</span><br><span class="line">    <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>数组索引签名</li>
</ol>
<p>共有支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用<code>number</code>来索引时，JavaScript会将它转换成<code>string</code>然后再去索引对象。 也就是说用<code>100</code>（一个<code>number</code>）去索引等同于使用<code>&quot;100&quot;</code>（一个<code>string</code>）去索引，因此两者需要保持一致。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="attr">breed</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：使用&#x27;string&#x27;索引，有时会得到Animal!</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NotOkay</span> &#123;</span><br><span class="line">    [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="title class_">Animal</span>;</span><br><span class="line">    [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="title class_">Dog</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadonlyStringArray</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myArray</span>: <span class="title class_">ReadonlyStringArray</span> = [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>];</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="string">&quot;Mallory&quot;</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>对象中主要包含了属性和方法。属性分为实例属性（对象的）和类属性（类的，静态属性，使用static定义）,方法同理。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//定义实例属性</span></span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;xiaofang&#x27;</span>;</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span> = <span class="number">12</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在属性前使用static关键字可以定义类属性，也叫静态属性</span></span><br><span class="line">    <span class="keyword">static</span> age :<span class="built_in">number</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实例方法</span></span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">sayhi</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> per = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">age</span>)</span><br></pre></td></tr></table></figure>

<p>构造函数</p>
<p>constructor会在对象创建时调用。在实例方法中，this就表示当前的实例，构造函数中可以通过this向新建的对象添加属性</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">name:stirng,age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span>=name;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span>=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span>=name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="title function_">sayHello</span>(<span class="params"></span>)&#123;&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">	<span class="comment">//重写</span></span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>super</strong></p>
<p>super表示父类。<strong>子类重写构造函数必须调用父类构造函数super</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="title function_">sayHello</span>(<span class="params"></span>)&#123;&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">	<span class="comment">//重写</span></span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">    	<span class="variable language_">super</span>.<span class="title function_">sayHello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(name);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span>=age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象类</strong></p>
<p>抽象类不能创建实例。抽象类中可以添加抽象方法。抽象方法没有方法体，且子类必须对抽象方法重写。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	 <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span>=name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">abstract</span> <span class="title function_">sayHello</span>():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">	<span class="comment">//重写，必须重写抽象类的方法，实现方法体</span></span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi,this is a dog named twig&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口</strong></p>
<p>接口用来定义一个类的结构应该包含哪些属性和方法，同时接口也可以当作类型声明去使用，定义类型规范。</p>
<p>接口可以重复声明，以所有同名的接口规范联合为准</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//描述一个对象的类型</span></span><br><span class="line"><span class="keyword">type</span> myType=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> myInterface&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口可以重复声明</span></span><br><span class="line"><span class="keyword">interface</span> myInterface&#123;</span><br><span class="line">    <span class="attr">gender</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:myInterface = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;sss&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">222</span>,</span><br><span class="line">    <span class="attr">gender</span>:<span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义类时，实现接口就是使类满足接口的要求。接口的作用就是提供了一个规范。ts的接口在编译后不存在。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> myInterface&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">name</span>=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hiiiii&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>私有属性</strong></p>
<p>private可以使得属性只能在属性内部访问，可以通过在类中添加方法使得私有属性被外部访问。</p>
<p>getter，setter方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//定义实例属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;xiaofang&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">age</span>:<span class="built_in">number</span> = <span class="number">12</span>;</span><br><span class="line">    <span class="title function_">getName</span>():<span class="built_in">string</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setName</span>(<span class="params">value:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span>=value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例方法</span></span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TS中设置getter、setter方法的方式，有了这个方法可以直接访问属性（其实是通过方法），而不必使用方法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">name</span>()&#123;</span><br><span class="line">	<span class="comment">//console.log(&#x27;getname&#x27;)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>protected, private,public 和Java都一样。</p>
<p>可以直接将<strong>属性定义在构造函数</strong>constructor中。复杂的不推荐</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name:<span class="built_in">string</span>,<span class="keyword">public</span> age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">		<span class="comment">//没有赋值代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/26/TypeScript/" data-id="cl3n2nhrb0001uswac3cmguqn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/26/hello-world/" class="article-date">
  <time datetime="2022-05-26T12:55:09.228Z" itemprop="datePublished">2022-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/26/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/26/hello-world/" data-id="cl3n2rvnu00009owaa1h1albb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/26/Node-js/">Node.js</a>
          </li>
        
          <li>
            <a href="/2022/05/26/test-my-site/">test_my_site</a>
          </li>
        
          <li>
            <a href="/2022/05/26/TypeScript/">TypeScript</a>
          </li>
        
          <li>
            <a href="/2022/05/26/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>